### clearing memory
rm(list = ls())

### setting the working directory
setwd("C:/Users/Guro/Google Drive/MSc Security Risk Management/3rd Semester/SNA/R") ### for Microsoft

## Setting the working directory (in Mac)
### setting the working directory
setwd("~/Desktop/DIPCON")

### install packages for graph illustrations and 
install.packages("dplyr") ## basic function
install.packages("igraph") ## graph illustration
install.packages("ggplot2") ## for elegant and complex plot graphs
install.packages("ggthemes") ## add-on to ggplot2

## loading packages
library(dplyr)
library(igraph)
library(ggplot2)
library(ggthemes)

## loading the data
df <- read.csv("DIPCON_3.0_Dyads.csv") # data and documentation from: http://www.u.arizona.edu/~volgy/data.html

## inspecting the data
df

### using dplyr to keep only relations for 2000
df2000 <- df %>% # selecting th data set
  filter(dipcon2000 > 0) %>% # keeping only the connections in 2000
  select(abbrev1, abbrev2) # selecting the variables
  
### using dplyr to keep only relations for 2005
df2005 <- df %>% # selecting th data set
  filter(dipcon2005 > 0) %>% # keeping only the connections in 2005
  select(abbrev1, abbrev2) # selecting the variables
  
### using dplyr to keep only relations for 2010
df2010 <- df %>% # selecting th data set
  filter(dipcon2010 > 0) %>% # keeping only the connections in 2010
  select(abbrev1, abbrev2) # selecting the variables
    
#Turning into a graph object
g2000 <- graph.data.frame(df2000, directed = F) # storing the graph as "undirected" for the sake of simplicity
g2005 <- graph.data.frame(df2005, directed = F) # storing the graph as "undirected" for the sake of simplicity
g2010 <- graph.data.frame(df2010, directed = F) # storing the graph as "undirected" for the sake of simplicity

### how many diplomatic ties does a country have on average in 2010
mean(degree(g2000))
mean(degree(g2005))
mean(degree(g2010))

### What is the density?
graph.density(g2000)
graph.density(g2005)
graph.density(g2010)

#### Plotting the graphs: 2000
plot.igraph(g2000, 
            vertex.color = 'lightblue', ### colour of node
            edge.label=df2000$value, ### adding names to the nodes
            vertex.size=5, ### size of node
            edge.color="darkgreen", ### colour of edge
            vertex.label.font= 1, ### font of node 
            vertex.label.cex = 1, ### size of node name label
            main='Diplomatic relations between states - 2000') ### Heading of graph

### Plotting the graphs: 2005
plot.igraph(g2005, 
            vertex.color = 'lightblue', ### colour of node
            edge.label=df2005$value, ### adding names to the nodes
            vertex.size=5, ### size of node
            edge.color="darkgreen", ### colour of edge
            vertex.label.font= 1, ### font of node 
            vertex.label.cex = 1, ### size of node name label
            main='Diplomatic relations between states - 2005') ### Heading of graph

### Plotting the graphs: 2010
plot.igraph(g2010, 
            vertex.color = 'lightblue', ### colour of node
            edge.label=df2010$value, ### adding names to the nodes
            vertex.size=5, ### size of node
            edge.color="darkgreen", ### colour of edge
            vertex.label.font= 1, ### font of node 
            vertex.label.cex = 1, ### size of node name label
            main='Diplomatic relations between states - 2010') ### Heading of graph


## exporting to gephi
write.graph(g2000, "dipcon2000.graphml", format = "graphml")
write.graph(g2005, "dipcon2005.graphml", format = "graphml")
write.graph(g2000, "dipcon2010.graphml", format = "graphml")

###################### indegree ranking #####################

##### Ranking countries by indegree - 2010
df10 <- df %>% filter(dipcon2010 > 0) %>% select(abbrev1, abbrev2)

## creating a graph object
g <- graph.data.frame(df10, directed = T)

### creating a data frame where columns represent variables and rows represent countires
df.g10 <- data.frame(country = V(g)$name,
                   indegree_norm = degree(g, mode = "in", normalized = T), #normalized indegree
                   indegree = degree(g, mode = "in", normalized = F )) # raw indegree

# ranking the countries by raw (non-normalized) indegree in descending order
df.g10 <- df.g10 %>% arrange(-indegree)

### examining the first 10 rows (top 10 countries ranked by (non-normalized) indegree)
head(df.g10, 10)

###### Ranking countries by indegree - 2005
df05 <- df %>% filter(dipcon2005 > 0) %>% select(abbrev1, abbrev2)

## creating a graph object
g <- graph.data.frame(df05, directed = T)

### creating a data frame where columns represent variables and rows represent countires
df.g05 <- data.frame(country = V(g)$name,
                     indegree_norm = degree(g, mode = "in", normalized = T), #normalized indegree
                     indegree = degree(g, mode = "in", normalized = F )) # raw indegree

# ranking the countries by raw (non-normalized) indegree in descending order
df.g05 <- df.g05 %>% arrange(-indegree)

### examining the first 10 rows (top 10 countries ranked by (non-normalized) indegree)
head(df.g05, 10)


###### Ranking countries by indegree - 2000
df00 <- df %>% filter(dipcon2000 > 0) %>% select(abbrev1, abbrev2)

## creating a graph object
g <- graph.data.frame(df00, directed = T)

### creating a data frame where columns represent variables and rows represent countires
df.g00 <- data.frame(country = V(g)$name,
                     indegree_norm = degree(g, mode = "in", normalized = T), #normalized indegree
                     indegree = degree(g, mode = "in", normalized = F )) # raw indegree

# ranking the countries by raw (non-normalized) indegree in descending order
df.g00 <- df.g00 %>% arrange(-indegree)

### examining the first 10 rows (top 10 countries ranked by (non-normalized) indegree)
head(df.g00, 10)


####### Trying to make a community structure in R ######
#this should detect communities for 2000
cluster_louvain(g2000, weights = NULL)

View(cluster_louvain(g2000, weights = NULL)) #It gives me the number of communities, but it is not exactly right
#R shows me 2 groups, whereas the US is in the last one
#Then R tells me that it has omitted several groups. 

cluster_louvain(g2005, weights = NULL) #try again for 2005
cluster_louvain(g2010, weights = NULL) #try again for 2010

##### This shows us there are four communities, which also is what we find in gephi.

#########################################################################################
#######################  Keeping only US as sending country for ########################
##################################   embassies   #########################################
#########################################################################################

### Now we want to see ONLY the US, to see what country relations they had from 2000-2010
#In order to not delete/ edit in our original dataset, we need to create a new dataframe.
#SLET - DET ER DET SAMME df1 <- c("abbrev1","abbrev2","dipcon2000","dipcon2005","dipcon2010")
#SLET - DET ER DET SAMME View(df1)

# Here we told the new dataframe to only have abbrev1, abbrev2, and the 3 years as columns. 
## Next I want to tell R how many rows of the data I want to use. 
df1 <- df[c(2:195), c(2,4,11,12,13)]
View(df1)
# Now we need R to tell us which embassies "happened" and got "recalled" in the timespan of 2000-2005

head(df1)
colnames(df1) # Get column names from df

## Clean datatable 
# remove rows with NA
nBefore = nrow(df1)

df1 = na.omit(df1)

nAfter = nrow(df1)
print(nBefore - nAfter)

## Create columns that calculates which embassies "happened" and "recalled" between years
df1$ec05 = ifelse( df1$dipcon2000!=df1$dipcon2005 ,1,0) #ec05 = embassy change. 1 = change between 2000 and 2005, 0 = no change
df1$ec10 = ifelse( df1$dipcon2005!=df1$dipcon2010 ,1,0) #ec10 = embassy change. 1 = change between 2005 and 2010, 0 = no change

dftest = df1
#If we print these two dataframe above, we will be able to see the changes with embassies only from the us perspective. We should def. write a section on this!


### using dplyr to keep only relations for 2000 for USA
dfUS00 <- df1 %>% # selecting th data set
  filter(dipcon2000 > 0) %>% # keeping only the connections in 2000
  select(abbrev1, abbrev2) # selecting the variables
  
### using dplyr to keep only relations for 2005 for USA
dfUS05 <- df1 %>% # selecting th data set
  filter(dipcon2005 > 0) %>% # keeping only the connections in 2005
  select(abbrev1, abbrev2) # selecting the variables
  
### using dplyr to keep only relations for 2010 for USA
dfUS10 <- df1 %>% # selecting th data set
  filter(dipcon2010 > 0) %>% # keeping only the connections in 2010
  select(abbrev1, abbrev2) # selecting the variables
  
#Turning into a graph object
gUS00 <- graph.data.frame(dfUS00, directed = F) # storing the graph as "undirected" for the sake of simplicity
gUS05 <- graph.data.frame(dfUS05, directed = F) # storing the graph as "undirected" for the sake of simplicity
gUS10 <- graph.data.frame(dfUS10, directed = F) # storing the graph as "undirected" for the sake of simplicity

### how many diplomatic ties does a country have on average in 2010
mean(degree(gUS00))
mean(degree(gUS05))
mean(degree(gUS10))


### What is the density?
graph.density(gUS00)
graph.density(gUS05)
graph.density(gUS10)

###########################################################################
#############  Detecting communities ######################################
###########################################################################


#### PROBLEM: How to export to gephi while showing the communities and the labels of the countries.


## Even though the graph object is sstored as "undirected", some edges may appear twice (in cases where reciprocal ties are directional)
g2000 <- simplify(g2000, remove.multiple = T, remove.loops = T) #use this function to remove multiples or self-ties 


### running infomap community detection
infomap.2000<- cluster_infomap(g2000, nb.trials = 10,
                               modularity = F)

# running modularity optimization community detection
modularity.2000 <- cluster_louvain(g2000)

## running Girvan and Newman's degree-based community detection
deg_com.2000 <- cluster_edge_betweenness(g2000)


### vizualising the network with communities (infomap)
plot.igraph(g2000,
            main ="Diplomatic ties in 2000 - infomap",
            vertex.size = 2,
            edge.label= NA,
            vertex.label = df2000$value, ### adding names to the nodes,
            vertex.label.color = "black",
            vertex.label.cex = 1,
            vertex.color = infomap.2000$membership)


### vizualising the network with communities (modularity optimisation)
plot.igraph(g2000,
            main="Diplomatic ties in 2000 - Modularity Optimization",
            vertex.size = 2,
            edge.label= NA,
            vertex.label = df2000$value, 
            vertex.label.color = "black",
            vertex.label.cex = 1,
            vertex.color = modularity.2000$membership)


### vizualising the network with communities (degree-based) - for 2000
plot.igraph(g2000,
            main="Diplomatic ties in 2000 - Degree Based",
            vertex.size = 2,
            vertex.label = df2000$value,
            vertex.label.color = "black",
            vertex.label.cex = 1,
            vertex.color = deg_com.2000$membership)


## exporting to gephi
write.graph(g2000, "dipcon2000.graphml", format = "graphml")

########### Visualizing for 2005 ##########
## Even though the graph object is stored as "undirected", some edges may appear twice (in cases where reciprocal ties are directional)
g2005 <- simplify(g2005, remove.multiple = T, remove.loops = T) #use this function to remove multiples or self-ties 


### running infomap community detection
infomap.2005<- cluster_infomap(g2005, nb.trials = 10,
                               modularity = F)

# running modularity optimization community detection
modularity.2005 <- cluster_louvain(g2005)

## running Girvan and Newman's degree-based community detection
deg_com.2005 <- cluster_edge_betweenness(g2005)

### vizualising the network with communities (infomap)
plot.igraph(g2005,
            main ="Diplomatic ties in 2005 - infomap",
            vertex.size = 2,
            edge.label= NA,
            vertex.label = df2005$value, ### adding names to the nodes,
            vertex.label.color = "black",
            vertex.label.cex = 1,
            vertex.color = infomap.2005$membership)

### vizualising the network with communities (modularity optimisation)
plot.igraph(g2005,
            main="Diplomatic ties in 2005 - Modularity Optimization",
            vertex.size = 2,
            edge.label= NA,
            vertex.label = df2005$value, 
            vertex.label.color = "black",
            vertex.label.cex = 1,
            vertex.color = modularity.2005$membership)

### vizualising the network with communities (degree-based) - for 2005
plot.igraph(g2005,
            main="Diplomatic ties in 2005 - Degree Based",
            vertex.size = 2,
            vertex.label = df2005$value,
            vertex.label.color = "black",
            vertex.label.cex = 1,
            vertex.color = deg_com.2005$membership)

## vizualising the network with communities (degree-based) - for 2005
plot.igraph(g2005,
            main="Diplomatic ties in 2005 - Degree Based",
            vertex.size = 5,
            vertex.label = df2005$value,
            vertex.label.color = "black",
            vertex.label.cex = 1,
            edge.color = "lightblue",
            vertex.color = deg_com.2005$membership)


## exporting to gephi
write.graph(g2005, "dipcon2005.graphml", format = "graphml")


########### Visualizing for 2010 ##########
## Even though the graph object is stored as "undirected", some edges may appear twice (in cases where reciprocal ties are directional)
g2010 <- simplify(g2010, remove.multiple = T, remove.loops = T) #use this function to remove multiples or self-ties 


### running infomap community detection
infomap.2010<- cluster_infomap(g2010, nb.trials = 10,
                               modularity = F)

# running modularity optimization community detection
modularity.2010 <- cluster_louvain(g2010)

## running Girvan and Newman's degree-based community detection
deg_com.2010 <- cluster_edge_betweenness(g2010)


### vizualising the network with communities (infomap)
plot.igraph(g2010,
            main ="Diplomatic ties in 2010 - infomap",
            vertex.size = 2,
            edge.label= NA,
            vertex.label = df2010$value, ### adding names to the nodes,
            vertex.label.color = "black",
            vertex.label.cex = 1,
            vertex.color = infomap.2010$membership)


### vizualising the network with communities (modularity optimisation) - for 2010
plot.igraph(g2010,
            main="Diplomatic ties in 2010 - Modularity Optimization",
            vertex.size = 2,
            edge.label= NA,
            vertex.label = df2010$value, 
            vertex.label.color = "black",
            vertex.label.cex = 1,
            vertex.color = modularity.2010$membership)


### vizualising the network with communities (degree-based) - for 2010
plot.igraph(g2010,
            main="Diplomatic ties in 2010 - Degree Based",
            vertex.size = 5,
            vertex.label = df2010$value,
            vertex.label.color = "black",
            vertex.label.cex = 1,
            edge.color = "lightblue",
            vertex.color = deg_com.2010$membership)


## exporting to gephi
write.graph(g2005, "dipcon2010.graphml", format = "graphml")

############################# K-Cores  ################################

V(g2000)$Kcore = graph.coreness(g2000)
#computing degree
V(g2000)$degree <- degree(g2000)

# examining the graph
plot(g2000,
     main="K Cores",
     vertex.size = 20,
     vertex.label = V(g2000)$Kcore,
     vertex.label.color = "black",
     vertex.label.cex = 1,
     vertex.color = "white")

# storing a list of nodes that belong to k <=10
exclude <- V(g2000)[Kcore < 10]

# removing these nodes in order to make a k-10 core
k10 <- delete.vertices(g2000, exclude)

### plotting k10
plot(k10,
     main="k-10 core",
     vertex.size = 20,
     vertex.label = V(k15)$Kcore,
     vertex.label.color = "black",
     vertex.label.cex = 1,
     vertex.color = "white")

### plotting k10 where color reflects k
plot(k10,
     main="K-10 core",
     vertex.size = 20,
     vertex.label = df2000$value,
     vertex.label.color = "black",
     vertex.label.cex = 1,
     vertex.color = V(k10)$Kcore)
     
############ NB: How to add labels to the colours of the k-cores so we know what the colours mean?
############ NB2: Is it possible to change the colours of the different degrees?


write.graph(k38, "DIPCON_k38.graphml", format = "graphml")








########################################  THINGS THAT DIDN'T HELP US WITH ANALYSIS ############################################

######## Didn't make sense to make a graph of the US embassies in other countries as the US is centralised and there is no clusters,
no weighting of edges, no cores of countries etc. It only shows us a star with the US in the center ############

#### Plotting the graphs: 2000
plot.igraph(gUS00, 
            vertex.color = 'lightblue', ### colour of node
            edge.label=df2000$value, ### adding names to the nodes
            vertex.size=5, ### size of node
            edge.color="darkgreen", ### colour of edge
            vertex.label.font= 1, ### font of node 
            vertex.label.cex = 1, ### size of node name label
            main='Diplomatic relations of US - 2000') ### Heading of graph

### Plotting the graphs: 2005
plot.igraph(gUS05, 
            vertex.color = 'lightblue', ### colour of node
            edge.label=df2005$value, ### adding names to the nodes
            vertex.size=5, ### size of node
            edge.color="darkgreen", ### colour of edge
            vertex.label.font= 1, ### font of node 
            vertex.label.cex = 1, ### size of node name label
            main='Diplomatic relations of US - 2005') ### Heading of graph

### Plotting the graphs: 2010
plot.igraph(gUS10, 
            vertex.color = 'lightblue', ### colour of node
            edge.label=df2010$value, ### adding names to the nodes
            vertex.size=5, ### size of node
            edge.color="darkgreen", ### colour of edge
            vertex.label.font= 1, ### font of node 
            vertex.label.cex = 1, ### size of node name label
            main='Diplomatic relations of US - 2010') ### Heading of graph


## exporting to gephi
write.graph(gUS00, "dipconUS00.graphml", format = "graphml")
write.graph(gUS05, "dipconUS05.graphml", format = "graphml")
write.graph(gUS00, "dipconUS10.graphml", format = "graphml")
